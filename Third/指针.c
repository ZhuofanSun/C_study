/**void swap(int, int);
int main() {
    int a = 10, b = 20;
    swap(a, b);

    printf("a = %d, b = %d", a, b);   //最后会得到什么结果？
}

void swap(int a, int b){
    int tmp = a;   //这里对a和b的值进行交换
    a = b;
    b = tmp;
}
**/

/**
#include <stdio.h>

int main(){
    int a = 10;
    //指针类型需要与变量的类型相同，且后面需要添加一个*符号（注意这里不是乘法运算）表示是对于类型的指针
    int * p = &a;   //这里的&并不是进行按位与运算，而是取地址操作，也就是拿到变量a的地址
    printf("a在内存中的地址为：%p", p);  //地址使用%p表示
}



     int x;
    scanf("%d", &x); // scanf需要给地址
    printf("%d", x);


   int x = 100;
   int y = 200;
   const int *p = &x;  // 指x的地址不可以修改，是只读模式, 但是可以改成y，可以改变指向
   int * const p = &x; // 指x的地址可以改修改，但是不可以改变指向
   const int * const p = &x; // 指针的指向和值都不可以修改

**/



/**
 *数组在内存中就是一块连续的空间，第一个元素的地址随机分配
 * 所以数组变量实际上存放的就是首元素的地址
 * 下标操作是操作地址
 * 数组要声明类型和大小，是因为这一块连续的内存空间生成后就固定了
 *
 *     * *p   //数组的第一个元素
ps   //数组的第一个元素的地址
ps == str   //肯定是真，因为都是数组首元素地址
*str    //因为str就是首元素的地址，所以这里对地址加*就代表第一个元素，使用的是指针表示法
&str[0]   //这里得到的实际上还是首元素的地址
*(ps + 1)   //代表第二个元素
ps + 1    //第二个元素的内存地址
*ps + 1    //注意*的优先级比+要高，所以这里代表的是首元素的值+1，得到字符'I'
 *
 *
*/
/**
* 二维数组
 * 还是指向第一个元素的地址，连续储存【【1，2，3】，【4，5，6】】还是1，2，3，4，5，6这么排列
*/
/**
* 多级指针
 *      int z = 20;
        int * pp = &z;   //指向普通变量的指针
        //因为现在要指向一个int *类型的变量，所以类型为int* 再加一个*
        int ** ppp = &pp;   //指向指针的指针（二级指针）
        int *** pppp = &ppp;   //指向指针的指针的指针（三级指针）
 *
 *
*/

/**
* 指针数组与数组指针
 *指针数组： 存放指针的数组
 *  int * arr[3] = {&a, &b, &c}; // 存放的都是地址
 *可以用二级指针指向数组指针
 * int **pp = arr;
 * printf("%d", **pp)// 访问a的值
 * printf("%d", **（pp+1）)// 访问b的值
 *
 *
 * 数组指针： 本质是个指针
 * 这个指针指向整个数组，而不是指向某种类型
 * int *p =; // 定义一个int类型的指针
 * int (*p)[3];  // []优先级更高，没有（）会先初始化一个新的数组 指向大小为3的数组
 * 举例：
 * int arr[3] = {1,2,3};
 * int (*p)[3] = &arr;//这个长度为3的数组指针指向的是代表整个数组的地址，(*p)[2] 就是数组里第二个元素
 * int *p = arr;// 这个指针指向的是数组第一个元素的地址，*(p+1)就是数组里第二个元素。
*/

/**
* 函数指针
 *
 * int sum(int a, int b){};
 * int (*p)(int, int) = sum; // 返回值为int，函数名称是（*p), 输入是（int, int)
 * p就是函数地址了
 * int result = p(1,2);// 和直接用函数一样，就是改了个名字
 * int sum(int (*p)(int,int), int a, int b);// 调用储存在p的函数，输入int a，b
 *
*/